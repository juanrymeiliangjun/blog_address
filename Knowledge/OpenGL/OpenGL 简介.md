# OpenGL 简介

现分析【在屏幕上显示出一个有颜色的三角形】的整个处理流程：(假设在最简单的情形下)

> ➀OpenGL空间中有3个3D坐标(vec3类型)并且设置每个坐标处的颜色都是绿色(3个颜色数据)，在C++程序中调用绘制三角形的GL函数glDrawArrays(GL_TRIANGLES, 0, 3); 将3个3D坐标数据传递进顶点着色器，程序同时也把3个颜色数据传递进顶点着色器；
>
> ➁在顶点着色器程序中将要绘制的三角形模型经[模型-视图矩阵] 和 [透视投影矩阵] 变换到有透视效果的相机空间，这时就形成新三角形(由变换后的3个3D坐标构成)，将新三角形的3个3D坐标数据和对应的3个颜色数据传送到光栅化阶段；
>
> ➂<font color=black>光栅化要完成能在屏幕上显示的三角形，即要形成像素三角形</font>。光栅化过程确定了用以显示3个顶点所确定的三角形的所有像素需要绘制的位置及颜色(都由线性插值产生)。确定了显示三角形的所有像素位置及颜色值后，就完成了光栅化工作。对于传递进来的颜色数据，由于3个颜色相同，所以线性插值后仍是原来的颜色(绿色)。如果3个顶点分别都有着不同的颜色，则颜色数据依三角形形状进行线性插值后，形成的三角形的所有像素的颜色值都将取自[线性平滑过渡颜色数据集]中的色值。接下来，将形成三角形的所有像素的插值位置和插值颜色，一个个地传递到片段着色器。
>
> ➃片段着色器基本功能就是给像素着色，在片段着色器中，将传递来的包含颜色信息的像素，直接定义out变量输出(当然也可进行颜色的其他处理操作，但对本演示，无需其他处理)，这样就完成了像素着色预处理工作。然后再将数据(此阶段未用到的像素位置数据，以及显式out输出的像素颜色数据)传递到图形管线的下一阶段。
>
> ➄测试与混合阶段，对所有像素位置进行深度测试(其实还可能有其他测试)；对所有像素颜色进行混合操作，混合(不同物体的)多种颜色为一种颜色。然后将处理后的像素数据传递到图形管线的下一阶段。
>
> ➅图像生成阶段，生成能正确在屏幕上显示的所需三角形图像(由像素位置集和像素颜色集组成)。
>
> ➆创建一个帧缓冲区来承载上一步产生的图像数据。最后，在屏幕上刷新出这一帧，也即完成了所要的结果：在屏幕上显示出了一个有颜色的三角形。
>
>
> 原文链接：https://blog.csdn.net/itzyjr/article/details/118076823

### 像素操作

(隐藏面消除、深度/颜色缓冲区&深度精度&深度测试、Z-Buffer算法、glClear())

## 参考

[OpenGL图像管线](https://blog.csdn.net/itzyjr/article/details/118076823)